<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>POP TWIN SHOOTER with SOUND</title>
<style>
    body {
        margin: 0;
        background-color: #222;
        color: #fff;
        font-family: 'Arial Rounded MT Bold', 'Helvetica Rounded', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        overflow: hidden;
    }
    #game-container {
        display: flex;
        gap: 20px;
        align-items: flex-start;
    }
    canvas {
        background-color: #9ACD32;
        border: 4px solid #fff;
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(0,0,0,0.8);
    }
    .instructions {
        background: #333;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        font-size: 14px;
        line-height: 1.6;
        width: 260px;
    }
    h3 { margin-top: 0; color: #FFD700; border-bottom: 2px solid #555; padding-bottom: 5px; }
    .key { display: inline-block; background: #555; padding: 2px 6px; border-radius: 4px; font-weight: bold; }
    .color-yellow { color: #FFD700; font-weight: bold; }
    .color-blue { color: #1E90FF; font-weight: bold; }
    .color-white { color: #FFFFFF; font-weight: bold; }
    .color-red { color: #FF4500; font-weight: bold; }
    .sound-notice { color: #00FF7F; font-weight: bold; font-size: 13px; margin-top: 10px; display: block;}
</style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    
    <div class="instructions">
        <h3>æ“ä½œæ–¹æ³•</h3>
        <p><span class="key">â†‘â†“â†â†’</span> ç§»å‹•</p>
        <p><span class="key">Z</span> å¯¾ç©ºã‚·ãƒ§ãƒƒãƒˆï¼ˆé•·æŠ¼ã—å¯ï¼‰</p>
        <p><span class="key">X</span> å¯¾åœ°ãƒœãƒ </p>
        <p><span class="key">Enter</span> é–‹å§‹ / ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</p>
        
        <h3>ãƒ™ãƒ«ã®åŠ¹æœ</h3>
        <p>
            <span class="color-yellow">â–  é»„è‰²ï¼š</span>ã‚¹ã‚³ã‚¢UP<br>
            <span class="color-blue">â–  é’è‰²ï¼š</span>ã‚¹ãƒ”ãƒ¼ãƒ‰UP<br>
            <span class="color-white">â–  ç™½è‰²ï¼š</span>ãƒ„ã‚¤ãƒ³ç ²<br>
            <span class="color-red">â–  èµ¤è‰²ï¼š</span>ãƒãƒªã‚¢ (è¢«å¼¾ã‚’1å›é˜²ã)<br>
            <span style="font-size: 12px; color: #aaa;">â€»ã‚·ãƒ§ãƒƒãƒˆã‚’5å›å½“ã¦ã‚‹ã”ã¨ã«å¤‰åŒ–</span>
        </p>

        <h3>ã‚·ã‚¹ãƒ†ãƒ </h3>
        <p>æ•µã®æ”»æ’ƒã‚’å—ã‘ã‚‹ã¨ã€æ®‹æ©ŸãŒæ¸›ã‚‹å‰ã«ã¾ãš<b>ä¸¡è…•ãŒå£Šã‚Œ</b>ã€å¯¾åœ°ãƒœãƒ ãŒæ’ƒã¦ãªããªã‚Šã¾ã™ã€‚</p>
        <p>è…•ãŒå£Šã‚ŒãŸç›´å¾Œã«é™ã‚Šã¦ãã‚‹<b>æ•‘æ€¥è»ŠğŸš‘</b>ã«è§¦ã‚Œã‚‹ã¨ç›´ã‚Šã¾ã™ï¼ˆå–ã‚Šé€ƒãŒã™ã¨ãã®ã¾ã¾é€²è¡Œï¼‰ã€‚</p>
        
        <span class="sound-notice">ğŸ”Š éŸ³å£°å¯¾å¿œï¼<br>â€»Enterã‚­ãƒ¼ã‚’æŠ¼ã™ã¨BGM/SEãŒé³´ã‚Šã¾ã™ã€‚</span>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WIDTH = canvas.width;
const HEIGHT = canvas.height;

// --- ã‚­ãƒ¼å…¥åŠ›ç®¡ç† ---
const keys = {};
document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'KeyZ', 'KeyX', 'Enter'].includes(e.code)) {
        e.preventDefault();
    }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// æ±ç”¨å½“ãŸã‚Šåˆ¤å®š
function isCollide(a, b) {
    const dx = a.x - b.x; const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy) < (a.r + b.r);
}

// ==========================================
// Web Audio API ã‚µã‚¦ãƒ³ãƒ‰ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ³¢å½¢åˆæˆï¼‰
// ==========================================
class SoundSystem {
    constructor() {
        this.ctx = null;
        this.bgmPlaying = false;
        this.nextNoteTime = 0;
        this.bassTime = 0;
        this.noteIndex = 0;
        this.bassIndex = 0;
        this.tempo = 150; // BPM
        this.beatLen = 60 / this.tempo;

        this.sirenOsc = null;
        this.sirenLfo = null;

        // éŸ³éšå‘¨æ³¢æ•°
        const C4=261.6, D4=293.7, Db4=277.2, E4=329.6, F4=349.2, G4=392.0, A4=440.0, B4=493.9;
        const C5=523.3, D5=587.3, E5=659.3, F5=698.5, G5=784.0, A5=880.0, B5=987.8, C6=1046.5;
        const _ = 0;

        // ãƒ„ã‚¤ãƒ³ãƒ“ãƒ¼é¢¨ãƒãƒƒãƒ—BGM [å‘¨æ³¢æ•°, 16åˆ†éŸ³ç¬¦åˆ†ã®é•·ã•]
        this.melody = [
            [C5,2], [E5,2], [G5,2], [C6,2], [A5,2], [F5,2], [C6,4],
            [G5,2], [E5,2], [G5,2], [F5,2], [E5,2], [D5,2], [C5,4],
            [D5,2], [F5,2], [A5,2], [G5,2], [F5,2], [E5,2], [D5,4],
            [C5,2], [E5,2], [G5,2], [C6,2], [A5,2], [B5,2], [C6,4]
        ];
        this.bass = [
            [C4,4], [G4,4], [F4,4], [C4,4], [C4,4], [G4,4], [C4,4], [G4,4],
            [D4,4], [A4,4], [G4,4], [D4,4], [C4,4], [G4,4], [F4,4], [C4,4]
        ];
    }
    
    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    playTone(freq, type, duration, vol, slideFreq=null, startTime=null) {
        if (!this.ctx || freq === 0) return;
        const t = startTime !== null ? startTime : this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, t);
        if (slideFreq) osc.frequency.exponentialRampToValueAtTime(slideFreq, t + duration);

        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(t); osc.stop(t + duration);
    }
    
    playNoise(duration, vol) {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 800;

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

        noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
        noise.start();
    }

    // --- åŠ¹æœéŸ³ç¾¤ ---
    seShoot()      { this.playTone(880, 'square', 0.1, 0.03, 440); }
    seBomb()       { this.playTone(400, 'sine', 0.3, 0.05, 100); }
    seExplosion()  { this.playNoise(0.3, 0.2); this.playTone(150, 'sawtooth', 0.3, 0.05, 50); }
    seEnemyHit()   { this.playTone(400, 'square', 0.1, 0.04, 200); }
    seCloud()      { this.playTone(800, 'sine', 0.1, 0.04, 1200); }
    seBellHit()    { this.playTone(1200, 'triangle', 0.1, 0.05, 1400); }
    seEnemyShot()  { this.playTone(1000, 'square', 0.1, 0.02, 600); }
    seDamage()     { this.playNoise(0.5, 0.2); this.playTone(200, 'sawtooth', 0.4, 0.08, 50); }
    
    seBellGet() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        this.playTone(659.25, 'square', 0.1, 0.04, null, t);
        this.playTone(880.00, 'square', 0.1, 0.04, null, t + 0.1);
        this.playTone(1046.50, 'square', 0.2, 0.04, null, t + 0.2);
    }
    seHeal() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        this.playTone(523.25, 'sine', 0.1, 0.05, null, t);
        this.playTone(659.25, 'sine', 0.1, 0.05, null, t + 0.1);
        this.playTone(783.99, 'sine', 0.2, 0.05, null, t + 0.2);
        this.playTone(1046.50, 'sine', 0.4, 0.05, null, t + 0.4);
    }
    seGameOver() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        this.playTone(293.7, 'sawtooth', 0.4, 0.05, 280, t);
        this.playTone(277.2, 'sawtooth', 0.4, 0.05, 260, t + 0.4);
        this.playTone(261.6, 'sawtooth', 0.8, 0.05, 200, t + 0.8);
    }

    // --- æ•‘æ€¥è»Šã®ã‚µã‚¤ãƒ¬ãƒ³ ---
    startSiren() {
        if (!this.ctx || this.sirenOsc) return;
        this.sirenOsc = this.ctx.createOscillator();
        this.sirenLfo = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const lfoGain = this.ctx.createGain();

        this.sirenOsc.type = 'sine';
        this.sirenOsc.frequency.value = 600;
        this.sirenLfo.type = 'square';
        this.sirenLfo.frequency.value = 2.5; // ã‚µã‚¤ãƒ¬ãƒ³ã®å‘¨æœŸ
        
        lfoGain.gain.value = 200;
        this.sirenLfo.connect(lfoGain);
        lfoGain.connect(this.sirenOsc.frequency);

        gain.gain.value = 0.02;
        this.sirenOsc.connect(gain);
        gain.connect(this.ctx.destination);

        this.sirenOsc.start();
        this.sirenLfo.start();
    }
    stopSiren() {
        if (this.sirenOsc) {
            this.sirenOsc.stop(); this.sirenLfo.stop();
            this.sirenOsc = null;
        }
    }

    // --- BGMåˆ¶å¾¡ ---
    startBGM() {
        this.init();
        if (this.bgmPlaying) return;
        this.bgmPlaying = true;
        this.nextNoteTime = this.ctx.currentTime + 0.1;
        this.bassTime = this.nextNoteTime;
        this.noteIndex = 0;
        this.bassIndex = 0;
    }
    stopBGM() { this.bgmPlaying = false; }
    
    updateBGM() {
        if (!this.bgmPlaying || !this.ctx) return;
        const ahead = 0.1;
        
        // ã‚¿ãƒ–éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ç­‰ã§æ™‚é–“ãŒå¤§ããã‚ºãƒ¬ãŸå ´åˆã®è£œæ­£
        if (this.nextNoteTime < this.ctx.currentTime) {
            this.nextNoteTime = this.ctx.currentTime + 0.05;
            this.bassTime = this.nextNoteTime;
        }

        while (this.nextNoteTime < this.ctx.currentTime + ahead) {
            const note = this.melody[this.noteIndex];
            const noteDur = note[1] * (this.beatLen / 4);
            if (note[0] !== 0) this.playTone(note[0], 'square', noteDur * 0.8, 0.02, null, this.nextNoteTime);
            this.nextNoteTime += noteDur;
            this.noteIndex = (this.noteIndex + 1) % this.melody.length;
        }
        while (this.bassTime < this.ctx.currentTime + ahead) {
            const bNote = this.bass[this.bassIndex];
            const bDur = bNote[1] * (this.beatLen / 4);
            if (bNote[0] !== 0) this.playTone(bNote[0], 'triangle', bDur * 0.8, 0.03, null, this.bassTime);
            this.bassTime += bDur;
            this.bassIndex = (this.bassIndex + 1) % this.bass.length;
        }
    }
}


// ==========================================
// ã‚²ãƒ¼ãƒ ã‚¯ãƒ©ã‚¹ç¾¤
// ==========================================

class Background {
    constructor() {
        this.y = 0; this.islands = [];
        for (let i = 0; i < 8; i++) {
            this.islands.push({
                x: Math.random() * WIDTH, y: Math.random() * HEIGHT,
                r: 30 + Math.random() * 40, color: Math.random() > 0.5 ? '#2E8B57' : '#3CB371'
            });
        }
    }
    update() { this.y += 1.5; if (this.y >= HEIGHT) this.y = 0; }
    draw(ctx) {
        ctx.fillStyle = '#9ACD32'; ctx.fillRect(0, 0, WIDTH, HEIGHT);
        for (let i = 0; i < 2; i++) {
            let offsetY = this.y - i * HEIGHT;
            this.islands.forEach(isl => {
                ctx.fillStyle = isl.color;
                ctx.beginPath(); ctx.arc(isl.x, isl.y + offsetY, isl.r, 0, Math.PI*2); ctx.fill();
            });
        }
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random() - 0.5) * 6; this.vy = (Math.random() - 0.5) * 6;
        this.life = 20 + Math.random() * 10; this.maxLife = this.life; this.active = true;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.life--; if (this.life <= 0) this.active = false;
    }
    draw(ctx) {
        ctx.fillStyle = this.color; ctx.globalAlpha = this.life / this.maxLife;
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
    }
}

class Player {
    constructor() {
        this.x = WIDTH / 2; this.y = HEIGHT - 50; this.r = 12;
        this.speed = 4; this.arms = true; this.twin = false;
        this.barrier = false; this.invincible = 0;
        this.shotCooldown = 0; this.bombCooldown = 0;
    }
    update(game) {
        if (this.invincible > 0) this.invincible--;
        if (this.shotCooldown > 0) this.shotCooldown--;
        if (this.bombCooldown > 0) this.bombCooldown--;

        if (keys['ArrowLeft']) this.x -= this.speed;
        if (keys['ArrowRight']) this.x += this.speed;
        if (keys['ArrowUp']) this.y -= this.speed;
        if (keys['ArrowDown']) this.y += this.speed;

        this.x = Math.max(this.r, Math.min(WIDTH - this.r, this.x));
        this.y = Math.max(this.r, Math.min(HEIGHT - this.r, this.y));

        if (keys['KeyZ'] && this.shotCooldown <= 0) {
            game.sounds.seShoot();
            if (this.twin) {
                game.bullets.push(new Bullet(this.x - 8, this.y)); game.bullets.push(new Bullet(this.x + 8, this.y));
            } else {
                game.bullets.push(new Bullet(this.x, this.y));
            }
            this.shotCooldown = 10;
        }

        if (keys['KeyX'] && this.bombCooldown <= 0 && this.arms) {
            game.sounds.seBomb();
            game.bombs.push(new Bomb(this.x, this.y, game.sounds));
            this.bombCooldown = 40;
        }
    }
    takeDamage(game) {
        if (this.barrier) {
            this.barrier = false; this.invincible = 60;
            game.sounds.seDamage();
            game.spawnParticles(this.x, this.y, '#FF4500', 15);
            return;
        }
        if (this.arms) {
            this.arms = false; this.invincible = 60;
            game.sounds.seDamage();
            game.sounds.startSiren();
            game.spawnParticles(this.x, this.y, '#1E90FF', 15);
            game.ambulances.push(new Ambulance(this.x, -20));
            return;
        }
        
        game.lives--;
        game.sounds.seExplosion();
        game.spawnParticles(this.x, this.y, '#1E90FF', 30);
        if (game.lives <= 0) {
            game.state = 'GAMEOVER';
            game.sounds.stopBGM();
            game.sounds.stopSiren();
            game.sounds.seGameOver();
        } else {
            this.x = WIDTH / 2; this.y = HEIGHT - 50;
            this.arms = true; this.twin = false; this.barrier = false; this.speed = 4;
            this.invincible = 120; game.enemyBullets = [];
        }
    }
    draw(ctx) {
        if (this.invincible > 0 && Math.floor(Date.now() / 100) % 2 === 0) return;

        if (this.barrier) {
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.r + 10, 0, Math.PI*2); ctx.stroke();
        }

        if (this.arms) {
            ctx.fillStyle = '#1E90FF';
            ctx.beginPath(); ctx.arc(this.x - 14, this.y, 5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(this.x + 14, this.y, 5, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(this.x - 10, this.y); ctx.lineTo(this.x - 14, this.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(this.x + 10, this.y); ctx.lineTo(this.x + 14, this.y); ctx.stroke();
        } else {
            ctx.fillStyle = '#555';
            ctx.beginPath(); ctx.arc(this.x - 10, this.y, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(this.x + 10, this.y, 3, 0, Math.PI*2); ctx.fill();
        }

        ctx.fillStyle = '#1E90FF'; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#87CEFA'; ctx.beginPath(); ctx.arc(this.x, this.y - 4, this.r * 0.6, 0, Math.PI*2); ctx.fill();
    }
}

class Bullet {
    constructor(x, y) { this.x = x; this.y = y; this.r = 4; this.active = true; }
    update() { this.y -= 12; if (this.y < -10) this.active = false; }
    draw(ctx) {
        ctx.fillStyle = '#FFFF00'; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#FF8C00'; ctx.lineWidth = 1; ctx.stroke();
    }
}

class Bomb {
    constructor(x, y, sounds) {
        this.x = x; this.y = y; this.vy = -3; this.vz = 5; this.z = 0;
        this.state = 'FLYING'; this.r = 0; this.active = true; this.timer = 0;
        this.sounds = sounds;
    }
    update() {
        if (this.state === 'FLYING') {
            this.z += this.vz; this.vz -= 0.25; this.y += this.vy;
            if (this.z <= 0) {
                this.z = 0; this.state = 'EXPLODING';
                this.sounds.seExplosion();
            }
        } else {
            this.r += 1.5; this.y += 1.5; this.timer++;
            if (this.timer > 20) this.active = false;
        }
    }
    draw(ctx) {
        if (this.state === 'EXPLODING') {
            ctx.fillStyle = `rgba(255, 69, 0, ${1 - this.timer/20})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = `rgba(255, 255, 0, ${1 - this.timer/20})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.r * 0.6, 0, Math.PI*2); ctx.fill();
        }
    }
}

class EnemyAir {
    constructor() {
        this.x = Math.random() * (WIDTH - 40) + 20; this.y = -20; this.r = 12;
        this.vx = (Math.random() - 0.5) * 2; this.vy = 2 + Math.random();
        this.active = true; this.timer = 0;
    }
    update(game) {
        this.x += this.vx; this.y += this.vy;
        if (this.x < this.r || this.x > WIDTH - this.r) this.vx *= -1;
        this.timer++;
        if (this.timer % 80 === 0 && Math.random() < 0.5) {
            game.enemyBullets.push(new EnemyBullet(this.x, this.y, game.player));
            game.sounds.seEnemyShot();
        }
        if (this.y > HEIGHT + 20) this.active = false;
    }
    draw(ctx) {
        ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.ellipse(this.x - 12, this.y - 4, 8, 4, -0.2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(this.x + 12, this.y - 4, 8, 4, 0.2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#FF69B4'; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(this.x - 4, this.y - 2, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(this.x + 4, this.y - 2, 2, 0, Math.PI*2); ctx.fill();
    }
}

class EnemyBullet {
    constructor(x, y, player) {
        this.x = x; this.y = y; this.r = 4;
        let dx = player.x - x; let dy = player.y - y;
        let dist = Math.hypot(dx, dy) || 1;
        this.vx = (dx / dist) * 3; this.vy = (dy / dist) * 3; this.active = true;
    }
    update() { this.x += this.vx; this.y += this.vy; if (this.x < -10 || this.x > WIDTH+10 || this.y < -10 || this.y > HEIGHT+10) this.active = false; }
    draw(ctx) {
        ctx.fillStyle = '#FF4500'; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(this.x - 1, this.y - 1, 1.5, 0, Math.PI*2); ctx.fill();
    }
}

class EnemyGround {
    constructor() { this.x = Math.random() * (WIDTH - 40) + 20; this.y = -20; this.r = 14; this.active = true; }
    update() { this.y += 1.5; if (this.y > HEIGHT + 20) this.active = false; }
    draw(ctx) {
        ctx.fillStyle = '#8B4513'; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#222'; ctx.fillRect(this.x - 4, this.y - 16, 8, 16);
        ctx.fillStyle = '#A0522D'; ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fill();
    }
}

class Cloud {
    constructor(x, y) { this.x = x; this.y = y; this.r = 18; this.active = true; }
    update() { this.y += 1.5; if (this.y > HEIGHT + 30) this.active = false; }
    draw(ctx) {
        ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.beginPath();
        ctx.arc(this.x, this.y - 4, 14, 0, Math.PI*2); ctx.arc(this.x - 12, this.y + 6, 12, 0, Math.PI*2); ctx.arc(this.x + 12, this.y + 6, 12, 0, Math.PI*2); ctx.fill();
    }
}

class Bell {
    constructor(x, y) { this.x = x; this.y = y; this.r = 12; this.vy = -2; this.hitCount = 0; this.active = true; }
    update() { this.vy += 0.1; if (this.vy > 2.5) this.vy = 2.5; this.y += this.vy; if (this.y > HEIGHT + 20) this.active = false; }
    hit() { this.hitCount++; this.vy = -4; }
    getColorIndex() { return Math.floor(this.hitCount / 5) % 4; }
    draw(ctx) {
        const colors = ['#FFD700', '#1E90FF', '#FFFFFF', '#FF4500'];
        ctx.fillStyle = colors[this.getColorIndex()];
        ctx.beginPath(); ctx.moveTo(this.x, this.y - 8); ctx.quadraticCurveTo(this.x + 10, this.y - 8, this.x + 12, this.y + 8);
        ctx.lineTo(this.x - 12, this.y + 8); ctx.quadraticCurveTo(this.x - 10, this.y - 8, this.x, this.y - 8); ctx.fill();
        ctx.strokeStyle = '#000'; ctx.stroke();
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(this.x, this.y + 8, 3, 0, Math.PI*2); ctx.fill();
    }
}

class Ambulance {
    constructor(x, y) { this.x = x; this.y = y; this.r = 16; this.active = true; }
    update() { this.y += 1.5; if (this.y > HEIGHT + 30) this.active = false; }
    draw(ctx) {
        ctx.fillStyle = '#FFF';
        if(ctx.roundRect) { ctx.beginPath(); ctx.roundRect(this.x - 16, this.y - 12, 32, 24, 4); ctx.fill(); ctx.strokeStyle = '#000'; ctx.stroke(); } 
        else { ctx.fillRect(this.x - 16, this.y - 12, 32, 24); }
        ctx.fillStyle = '#FF0000'; ctx.fillRect(this.x - 4, this.y - 6, 8, 12); ctx.fillRect(this.x - 8, this.y - 2, 16, 4);
        ctx.fillStyle = (Math.floor(Date.now() / 150) % 2 === 0) ? '#FF0000' : '#8B0000'; ctx.beginPath(); ctx.arc(this.x, this.y - 12, 4, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#222'; ctx.fillRect(this.x - 12, this.y + 10, 6, 4); ctx.fillRect(this.x + 6, this.y + 10, 6, 4);
    }
}

// --- ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ  ---
class Game {
    constructor() {
        this.state = 'TITLE';
        this.bg = new Background();
        this.sounds = new SoundSystem();
    }
    init() {
        this.sounds.startBGM();
        this.score = 0; this.lives = 3; this.player = new Player();
        this.bullets = []; this.bombs = [];
        this.enemiesAir = []; this.enemiesGround = []; this.enemyBullets = [];
        this.clouds = []; this.bells = []; this.ambulances = []; this.particles = [];
        this.frame = 0; this.state = 'PLAYING';
    }
    spawnParticles(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) this.particles.push(new Particle(x, y, color));
    }
    update() {
        if (this.state === 'TITLE' || this.state === 'GAMEOVER') {
            if (keys['Enter']) { this.init(); keys['Enter'] = false; }
            this.bg.update(); return;
        }

        this.frame++;
        this.bg.update();
        this.player.update(this);
        this.sounds.updateBGM(); // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«åŒæœŸ

        if (this.frame % 80 === 0) this.enemiesAir.push(new EnemyAir());
        if (this.frame % 150 === 0) this.enemiesGround.push(new EnemyGround());
        if (this.frame % 200 === 0) this.clouds.push(new Cloud(Math.random() * (WIDTH - 60) + 30, -20));

        this.bullets.forEach(b => b.update()); this.bombs.forEach(b => b.update());
        this.enemiesAir.forEach(e => e.update(this)); this.enemiesGround.forEach(e => e.update());
        this.enemyBullets.forEach(b => b.update()); this.clouds.forEach(c => c.update());
        this.bells.forEach(b => b.update()); this.ambulances.forEach(a => a.update());
        this.particles.forEach(p => p.update());

        this.checkCollisions();

        let hadAmbulance = this.ambulances.length > 0;

        this.bullets = this.bullets.filter(b => b.active); this.bombs = this.bombs.filter(b => b.active);
        this.enemiesAir = this.enemiesAir.filter(e => e.active); this.enemiesGround = this.enemiesGround.filter(e => e.active);
        this.enemyBullets = this.enemyBullets.filter(e => e.active); this.clouds = this.clouds.filter(c => c.active);
        this.bells = this.bells.filter(b => b.active); this.ambulances = this.ambulances.filter(a => a.active);
        this.particles = this.particles.filter(p => p.active);

        // æ•‘æ€¥è»ŠãŒã„ãªããªã£ãŸã‚‰ã‚µã‚¤ãƒ¬ãƒ³ã‚’æ­¢ã‚ã‚‹
        if (hadAmbulance && this.ambulances.length === 0) {
            this.sounds.stopSiren();
        }
    }
    
    checkCollisions() {
        this.bullets.forEach(b => {
            if (!b.active) return;
            this.enemiesAir.forEach(e => {
                if (e.active && b.active && isCollide(b, e)) {
                    b.active = false; e.active = false; this.score += 100;
                    this.sounds.seEnemyHit(); this.spawnParticles(e.x, e.y, '#FF69B4');
                }
            });
            this.clouds.forEach(c => {
                if (c.active && b.active && isCollide(b, c)) {
                    b.active = false; c.active = false;
                    this.sounds.seCloud(); this.bells.push(new Bell(c.x, c.y)); this.spawnParticles(c.x, c.y, '#FFF');
                }
            });
            this.bells.forEach(bell => {
                if (bell.active && b.active && isCollide(b, bell)) {
                    b.active = false; bell.hit(); this.sounds.seBellHit();
                }
            });
        });

        this.bombs.forEach(b => {
            if (b.state === 'EXPLODING' && b.active) {
                this.enemiesGround.forEach(e => {
                    if (e.active && isCollide({x: b.x, y: b.y, r: b.r}, e)) {
                        e.active = false; this.score += 200;
                        this.sounds.seEnemyHit(); this.spawnParticles(e.x, e.y, '#8B4513');
                    }
                });
            }
        });

        this.bells.forEach(bell => {
            if (bell.active && isCollide(this.player, bell)) {
                bell.active = false; this.sounds.seBellGet();
                const colorIdx = bell.getColorIndex();
                if (colorIdx === 0) this.score += 500;
                else if (colorIdx === 1) this.player.speed = 6.5;
                else if (colorIdx === 2) this.player.twin = true;
                else if (colorIdx === 3) this.player.barrier = true;
                this.spawnParticles(this.player.x, this.player.y, ['#FFD700','#1E90FF','#FFFFFF','#FF4500'][colorIdx]);
            }
        });

        this.ambulances.forEach(amb => {
            if (amb.active && isCollide(this.player, amb)) {
                amb.active = false;
                if (!this.player.arms) {
                    this.player.arms = true; this.score += 500;
                    this.sounds.seHeal(); this.spawnParticles(this.player.x, this.player.y, '#FFF');
                }
            }
        });

        if (this.player.invincible <= 0) {
            let hit = false;
            this.enemiesAir.forEach(e => { if (e.active && isCollide(this.player, e)) { e.active = false; hit = true; } });
            this.enemyBullets.forEach(b => { if (b.active && isCollide(this.player, b)) { b.active = false; hit = true; } });
            if (hit) this.player.takeDamage(this);
        }
    }
    
    draw(ctx) {
        this.bg.draw(ctx);

        if (this.state === 'TITLE') {
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = '#FFF'; ctx.textAlign = 'center';
            ctx.font = 'bold 32px sans-serif'; ctx.fillText('POP TWIN SHOOTER', WIDTH/2, HEIGHT/2 - 20);
            ctx.font = '16px sans-serif'; ctx.fillText('Press ENTER to Start', WIDTH/2, HEIGHT/2 + 30);
            return;
        }

        this.enemiesGround.forEach(e => e.draw(ctx));
        this.bombs.filter(b => b.state === 'EXPLODING').forEach(b => b.draw(ctx));
        this.bombs.filter(b => b.state === 'FLYING').forEach(b => {
            ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(b.x, b.y, 6, 3, 0, 0, Math.PI*2); ctx.fill();
        });

        this.clouds.forEach(c => c.draw(ctx)); this.bells.forEach(b => b.draw(ctx));
        this.ambulances.forEach(a => a.draw(ctx)); this.enemiesAir.forEach(e => e.draw(ctx));
        this.enemyBullets.forEach(b => b.draw(ctx));

        this.bombs.filter(b => b.state === 'FLYING').forEach(b => {
            ctx.fillStyle = '#FF4500'; ctx.beginPath(); ctx.arc(b.x, b.y - b.z, 6, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(b.x - 2, b.y - b.z - 2, 2, 0, Math.PI*2); ctx.fill();
        });

        if (this.state === 'PLAYING') this.player.draw(ctx);
        this.bullets.forEach(b => b.draw(ctx)); this.particles.forEach(p => p.draw(ctx));

        ctx.fillStyle = '#FFF'; ctx.font = 'bold 20px sans-serif';
        ctx.textAlign = 'left'; ctx.fillText(`SCORE: ${this.score}`, 10, 30);
        ctx.textAlign = 'right'; ctx.fillText(`LIVES: ${this.lives}`, WIDTH - 10, 30);

        if (this.state === 'GAMEOVER') {
            ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = '#FF4500'; ctx.textAlign = 'center';
            ctx.font = 'bold 40px sans-serif'; ctx.fillText('GAME OVER', WIDTH/2, HEIGHT/2 - 20);
            ctx.fillStyle = '#FFF'; ctx.font = '20px sans-serif'; ctx.fillText('Press ENTER to Restart', WIDTH/2, HEIGHT/2 + 30);
        }
    }
}

// --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—å®Ÿè¡Œ ---
let game = new Game();
function loop() {
    requestAnimationFrame(loop);
    game.update();
    game.draw(ctx);
}
loop();
</script>
</body>
</html>
